shell的模式匹配和正则表达式

正则表达式一般是bash支持。
其中，有两个运算符号： [[ "$a" == XX*XX?XX ]] 和 [[ "$a" =~ [XX*] ]] 都支持匹配。前者叫模式匹配,通配符不能被双引号包含，否则变为普通字符；后者叫正则表达式。

一，== 的匹配。
    1，匹配以ABC开头的字符串。（ABC如果不是开头，则不匹配）。
        reg="ABC*"                //只匹配以ABC开头的字符串
        str="ABC-DEF"
        if [[ "$str" == $reg ]];then 
    2，匹配以ABC开头，DEF结尾的字符串。（ABC如果不是开头，则不匹配；DEF如果不是结尾，则不匹配）。
        reg="ABC*DEF"                //只匹配以ABC开头，DEF结尾的字符串
        str="ABC-DEF"
        if [[ "$str" == $reg ]];then        
    3，匹配以ABC开头，并且后面出现了DEF，且DEF后面有任意字符串。（ABC如果不是开头，则不匹配；DEF后面可以有或无字符串）。
        reg="ABC*DEF*"                //只匹配以ABC开头，后面出现DEF，且DEF不一定是结尾
        str="ABC-DEF"
        if [[ "$str" == $reg ]];then
    4，匹配前面有任意字符，接着出现ABC，再有任意字符，接着出现DEF，再接任意字符的字符串
        即，匹配中间含有"ABC任意字符DEF"这样的字符串的字符串。 （ABC可以不是开头，DEF可以不是结尾。ABC和DEF之间也可以没有字符串）。
        reg="*ABC*DEF*"                
        str="ABC-DEF"
        if [[ "$str" == $reg ]]





1，匹配

         if [[ "$1" =~ ["abc*def"] ]]; then
             echo "$each"
             break
         fi
         
         判断ip
^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$
